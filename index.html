<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Aircraft â€” Final Fixed (Mobile)</title>
<style>
  :root{--topbar:10vh;--gameh:75vh;--botbar:15vh}
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;touch-action:none;-webkit-user-select:none;user-select:none}
  .wrap{width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .topbar{height:var(--topbar);width:100%;background:#000;flex:0 0 var(--topbar)}
  .frame{width:100%;height:var(--gameh);max-width:900px;position:relative;overflow:hidden;background:#000;flex:0 0 var(--gameh)}
  canvas{display:block;width:100%;height:100%}
  .bottombar{height:var(--botbar);width:100%;background:#000;flex:0 0 var(--botbar)}
  .hud{position:absolute;left:8px;top:8px;z-index:50;color:#fff;font-family:Arial,Helvetica,sans-serif}
  .hud .score{font-weight:700}
  .hud .hearts img{width:34px;height:34px;margin-left:6px}
  .power-row{position:absolute;right:8px;top:8px;display:flex;flex-direction:column;gap:8px;z-index:50}
  .power-row img{width:44px;height:44px}
  #loading{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;z-index:60;font-family:Arial}
  .popup{position:absolute;left:50%;transform:translateX(-50%);top:20%;color:#fff;font-family:Arial;font-weight:700;pointer-events:none;opacity:0;transition:opacity .3s, transform .3s}
  @media(max-width:420px){ .hud .hearts img{width:30px;height:30px} .power-row img{width:38px;height:38px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar"></div>

    <div class="frame" id="frame">
      <canvas id="canvas"></canvas>

      <div class="hud" id="hud">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="hearts" id="hearts">
          <img src="./assets/heart.png" alt="h"><img src="./assets/heart.png" alt="h"><img src="./assets/heart.png" alt="h">
        </div>
      </div>

      <div class="power-row" id="powerRow" style="display:none"></div>
      <div id="loading">Loading assets... 0%</div>
      <div id="popup" class="popup"></div>
    </div>

    <div class="bottombar"></div>
  </div>

  <audio id="bgm" src="./sounds/bgm.mpeg" loop></audio>

<script>
/* FINAL FIXED VERSION
   - responsive canvas (devicePixelRatio aware)
   - swipe step + drag in bottom fixed area (horizontal only)
   - clamped player (never off-screen)
   - player fire 100ms, enemy fire 500ms, enemy spawn 1000ms
   - single power on screen every 2000ms, no clustering
   - boss spawn at 1000 and every +500 -> spawn 2 bosses
   - popup on power collect
*/

/* ---------- CONFIG ---------- */
const PATHS = {
  bg: './assets/background.png',
  player: './assets/player.png',
  enemy: './assets/enemy.png',
  boss: './assets/boss.png',
  bulletP: './assets/bullet_green.png',
  bulletE: './assets/bullet_red.png',
  powerDouble: './assets/power_double_fire.png',
  powerShield: './assets/power_shield.png',
  powerLife: './assets/power_extra_life.png',
  heart: './assets/heart.png'
};

const PLAYER_FIRE_MS = 100;   // 0.1s
const ENEMY_FIRE_MS  = 500;   // 0.5s (updated)
const ENEMY_SPAWN_MS = 1000;  // 1s
const POWER_SPAWN_MS = 2000;  // 2s
const SWIPE_STEP = 60;
const SWIPE_THRESHOLD = 30;
const POWER_DROP_CHANCE = 0.22;

/* ---------- CANVAS SETUP (DPR aware) ---------- */
const frame = document.getElementById('frame');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, window.devicePixelRatio || 1);

function fitCanvas(){
  const rect = frame.getBoundingClientRect();
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  canvas.width = Math.round(rect.width * DPR);
  canvas.height = Math.round(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // keep drawing in CSS pixels
}
fitCanvas();
window.addEventListener('resize', ()=>{ fitCanvas(); positionPlayer(); });

/* ---------- LOAD IMAGES ---------- */
const imgs = {};
let toLoad = Object.keys(PATHS).length;
const loadingEl = document.getElementById('loading');
for(const [k,p] of Object.entries(PATHS)){
  const I = new Image();
  I.src = p;
  I.onload = ()=>{ imgs[k]=I; toLoad--; loadingEl.textContent = `Loading assets... ${Math.round(((Object.keys(PATHS).length)-toLoad)/Object.keys(PATHS).length*100)}%`; if(toLoad===0) startGame(); };
  I.onerror = ()=>{ loadingEl.textContent = `Asset load failed: ${p}`; console.error('Asset load error',p); };
}

/* ---------- AUDIO ---------- */
const bgm = document.getElementById('bgm'); bgm.volume = 0.35;
function ensurePlayBgm(){ bgm.play().catch(()=>{ document.addEventListener('touchstart', ()=> bgm.play(), {once:true}); }); }

/* ---------- STATE ---------- */
let running = false;
let score = 0;
const scoreEl = document.getElementById('score');
const heartsDOM = document.getElementById('hearts');
const powerRow = document.getElementById('powerRow');
const popupEl = document.getElementById('popup');

const player = { x:0, y:0, w:64, h:64, lives:3, hitCount:0, fireLevel:0, shieldUntil:0 };
let bgY = 0;

let enemies = [], bosses = [], bulletsP = [], bulletsE = [], powers = [];
let lastPlayerShot = 0, lastEnemySpawn = 0, lastPowerSpawn = 0;
let lastBossSpawnScore = 0;

/* ---------- HELPERS ---------- */
const rand = (a,b)=> Math.random()*(b-a)+a;
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
const now = ()=> Date.now();
const rectOverlap = (A,B)=> A.x < B.x + B.w && A.x + A.w > B.x && A.y < B.y + B.h && A.y + A.h > B.y;

function updateHUD(){
  scoreEl.textContent = score;
  for(let i=0;i<3;i++) heartsDOM.children[i].style.display = (i < player.lives) ? 'inline-block' : 'none';
  powerRow.innerHTML = '';
  if(player.fireLevel>0){ const el = document.createElement('img'); el.src = PATHS.powerDouble; el.title = player.fireLevel===1 ? '2X Fire' : '3X Fire'; powerRow.appendChild(el); }
  if(player.shieldUntil > Date.now()){ const el = document.createElement('img'); el.src = PATHS.powerShield; el.title = 'Shield'; powerRow.appendChild(el); }
  powerRow.style.display = powerRow.children.length ? 'flex' : 'none';
}

/* ---------- SIZING ---------- */
function positionPlayer(){
  const rect = frame.getBoundingClientRect();
  // player size relative to frame width
  player.w = Math.round(Math.min(rect.width * 0.14, imgs.player.width || 64));
  player.h = Math.round(player.w * ((imgs.player.height || player.w) / (imgs.player.width || player.w)));
  player.x = clamp((rect.width - player.w) / 2, 6, rect.width - player.w - 6);
  player.y = rect.height - player.h - Math.round(rect.height * 0.06);
}
function clampPlayer(){
  const rect = frame.getBoundingClientRect();
  player.x = clamp(player.x, 6, rect.width - player.w - 6);
  player.y = clamp(player.y, 6, rect.height - player.h - 6);
}

/* ---------- SPAWN ---------- */
function spawnEnemy(){
  const rect = frame.getBoundingClientRect();
  const w = Math.round(Math.min(rect.width*0.12, imgs.enemy.width || 48));
  const h = Math.round(w * ((imgs.enemy.height || w) / (imgs.enemy.width || w)));
  enemies.push({ x: rand(8, rect.width - w - 8), y: -h - 8, w, h, speed: rand(1.1,1.8), hits:0, fade:false, alpha:1, lastShot: Date.now() + rand(200,600) });
}

function spawnPowerRandom(){
  const rect = frame.getBoundingClientRect();
  if(powers.length > 0) return; // only 1 power at a time
  const w = Math.round(Math.min(rect.width*0.09, imgs.powerDouble.width || 48));
  const h = Math.round(w * ((imgs.powerDouble.height || w) / (imgs.powerDouble.width || w)));
  // pick a position inside playable area away from edges
  const px = rand(30, rect.width - 30 - w);
  const py = rand(30, rect.height - 130 - h); // stay above bottom controls
  const types = ['life','double','shield'];
  const t = types[Math.floor(Math.random()*types.length)];
  powers.push({ x: px, y: py, w, h, type: t, vy: 0.6 });
}

/* ---------- BOSS SPAWN RULE ----------
 At 1000 -> spawn 2 bosses. After that every +500 -> spawn 2 bosses.
*/
function spawnBossPair(){
  const rect = frame.getBoundingClientRect();
  const w = Math.round(Math.min(rect.width*0.28, imgs.boss.width || 200));
  const h = Math.round(w * ((imgs.boss.height || w) / (imgs.boss.width || w)));
  // two bosses: left and right
  bosses.push({ x: 40, y: -h - 10, w, h, vx: 1.2, hp: 40, fade:false, alpha:1, fireTimer:0 });
  bosses.push({ x: rect.width - 40 - w, y: -h - 10, w, h, vx: -1.2, hp: 40, fade:false, alpha:1, fireTimer:0 });
}

/* ---------- FIRE ---------- */
function playerShoot(){
  const bw = Math.round(player.w*0.14), bh = Math.round(player.h*0.28);
  if(player.fireLevel === 0){
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
  } else if(player.fireLevel === 1){
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
  } else {
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 6, w: bw, h: bh, spd: 30 });
  }
}

function enemyFire(e){
  const bw = Math.round(e.w*0.12), bh = Math.round(e.h*0.28);
  bulletsE.push({ x: e.x + e.w/2 - bw/2, y: e.y + e.h + 6, w: bw, h: bh, spd: 6, color:'red' });
}

function bossFire3(b){
  const bw = Math.round(b.w*0.14), bh = Math.round(b.h*0.28);
  const lanes = [ b.x + 8, b.x + b.w/2 - bw/2, b.x + b.w - bw - 8 ];
  for(let i=0;i<3;i++){
    const lx = clamp(lanes[i], 6, (frame.getBoundingClientRect().width) - bw - 6);
    bulletsE.push({ x: lx, y: b.y + b.h + 6, w: bw, h: bh, spd: 6, color:'green' });
  }
}

/* ---------- UPDATE & COLLISIONS ---------- */
let lastFrame = performance.now();
function update(ts){
  const dt = Math.max(1, ts - lastFrame);
  lastFrame = ts;

  const rect = frame.getBoundingClientRect();

  // background scroll
  bgY += 1.2 * (dt/16); if(bgY >= rect.height) bgY = 0;

  // auto player fire
  if(now() - lastPlayerShot > PLAYER_FIRE_MS){ lastPlayerShot = now(); playerShoot(); }

  // spawn enemies
  if(now() - lastEnemySpawn > ENEMY_SPAWN_MS){ lastEnemySpawn = now(); spawnEnemy(); }

  // periodic power spawn (ensure only 1 power)
  if(now() - lastPowerSpawn > POWER_SPAWN_MS){ lastPowerSpawn = now(); spawnPowerRandom(); }

  // update enemies and enemy shooting
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.speed * (dt/16);
    if(now() - e.lastShot > ENEMY_FIRE_MS + Math.random()*200){ e.lastShot = now(); enemyFire(e); }
    if(e.y > rect.height + 80) enemies.splice(i,1);
  }

  // update bosses
  for(let i=bosses.length-1;i>=0;i--){
    const b = bosses[i];
    b.x += b.vx * (dt/16);
    if(b.x < 6 || b.x + b.w > rect.width - 6) b.vx *= -1;
    // occasional 3-lane bursts (controlled by probability)
    if(Math.random() < 0.008) bossFire3(b);
  }

  // update bullets
  for(let i=bulletsP.length-1;i>=0;i--){ bulletsP[i].y -= bulletsP[i].spd * (dt/16); if(bulletsP[i].y < -120) bulletsP.splice(i,1); }
  for(let i=bulletsE.length-1;i>=0;i--){ bulletsE[i].y += bulletsE[i].spd * (dt/16); if(bulletsE[i].y > rect.height + 200) bulletsE.splice(i,1); }

  // update powers (they fall slowly)
  for(let i=powers.length-1;i>=0;i--){ powers[i].y += powers[i].vy * (dt/16); if(powers[i].y > rect.height + 80) powers.splice(i,1); }

  // collisions: player bullets -> enemies (3 hits to die)
  for(let i=bulletsP.length-1;i>=0;i--){
    const pb = bulletsP[i];
    // enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(rectOverlap({x:pb.x,y:pb.y,w:pb.w,h:pb.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
        bulletsP.splice(i,1);
        e.hits = (e.hits||0) + 1;
        e.alpha = 1;
        if(e.hits >= 3){ e.fade = true; e.alpha = 1; if(Math.random() < POWER_DROP_CHANCE) spawnPowerRandom(); score += 10; updateHUD(); }
        break;
      }
    }
    // bosses (1 hp per hit)
    for(let bi=bosses.length-1;bi>=0;bi--){
      const bo = bosses[bi];
      if(rectOverlap({x:pb.x,y:pb.y,w:pb.w,h:pb.h},{x:bo.x,y:bo.y,w:bo.w,h:bo.h})){
        bulletsP.splice(i,1);
        bo.hp -= 1;
        bo.alpha = 1;
        if(bo.hp <= 0){ bo.fade = true; bo.alpha = 1; }
        score += 1; updateHUD();
        break;
      }
    }
  }

  // remove faded enemies & bosses
  for(let i=enemies.length-1;i>=0;i--){ if(enemies[i].fade){ enemies[i].alpha -= 0.06 * (dt/16); if(enemies[i].alpha <= 0) enemies.splice(i,1); } }
  for(let i=bosses.length-1;i>=0;i--){ if(bosses[i].fade){ bosses[i].alpha -= 0.03 * (dt/16); if(bosses[i].alpha <= 0){ bosses.splice(i,1); score += 100; updateHUD(); } } }

  // enemy bullets -> player: 3 hits to reduce one life
  for(let i=bulletsE.length-1;i>=0;i--){
    const eb = bulletsE[i];
    if(rectOverlap({x:eb.x,y:eb.y,w:eb.w,h:eb.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      bulletsE.splice(i,1);
      if(player.shieldUntil > Date.now()){
        // shield protects
      } else {
        player.hitCount = (player.hitCount||0) + 1;
        // blink effect triggered by setting blinkUntil (handled in draw)
        player.blinkUntil = now() + 800;
        if(player.hitCount >= 3){
          player.hitCount = 0;
          player.lives = Math.max(0, player.lives - 1);
          updateHUD();
          if(player.lives <= 0){
            running = false;
            setTimeout(()=>{ alert('Game Over! Score: ' + score); location.reload(); }, 60);
            return;
          }
        }
      }
    }
  }

  // player picks power
  for(let i=powers.length-1;i>=0;i--){
    const p = powers[i];
    if(rectOverlap({x:p.x,y:p.y,w:p.w,h:p.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      // apply
      if(p.type === 'life'){
        player.lives = Math.min(3, player.lives + 1);
        showPopup('Life +1');
      } else if(p.type === 'double'){
        player.fireLevel = Math.min(2, player.fireLevel + 1);
        showPopup(player.fireLevel === 1 ? '2X Fire' : '3X Fire');
      } else if(p.type === 'shield'){
        player.shieldUntil = Date.now() + 5000;
        showPopup('Shield Activated');
      }
      powers.splice(i,1);
      updateHUD();
    }
  }

  // boss spawn rule: at 1000 -> spawn 2 bosses; afterwards every +500 -> spawn 2 bosses
  if(score >= 1000 && (lastBossSpawnScore === undefined || score - (lastBossSpawnScore||0) >= 500)){
    if(lastBossSpawnScore === undefined || score === 1000 || score - (lastBossSpawnScore||0) >= 500){
      spawnBossPairIfAllowed();
      lastBossSpawnScore = score;
    }
  }

  // victory check (optional)
  if(score >= 1000 && bosses.length === 0 && enemies.length === 0 && powers.length === 0){
    // keep playing â€” per your rule bosses keep coming every +500; but if you want a win state add here
  }
}

/* spawn pair helper with limit */
function spawnBossPairIfAllowed(){
  // spawn 2 bosses
  spawnBossPair();
}

/* ---------- DRAW ---------- */
function draw(){
  // clear using CSS pixels (ctx has DPR transform)
  const rect = frame.getBoundingClientRect();
  ctx.clearRect(0,0,rect.width,rect.height);

  // background (tiled vertical)
  if(imgs.bg){
    const h = rect.height;
    const y = (bgY % h);
    ctx.drawImage(imgs.bg, 0, y - h, rect.width, h);
    ctx.drawImage(imgs.bg, 0, y, rect.width, h);
  } else {
    ctx.fillStyle = '#071022'; ctx.fillRect(0,0,rect.width,rect.height);
  }

  // draw powers
  powers.forEach(p => {
    const img = (p.type==='life') ? imgs.powerLife : (p.type==='double') ? imgs.powerDouble : imgs.powerShield;
    ctx.drawImage(img, p.x, p.y, p.w, p.h);
  });

  // draw enemies (with fade)
  enemies.forEach(e => { ctx.save(); ctx.globalAlpha = e.fade ? (e.alpha||1) : 1; ctx.drawImage(imgs.enemy, e.x, e.y, e.w, e.h); ctx.restore(); });

  // draw bosses (with HP bar)
  bosses.forEach(b => {
    ctx.save(); ctx.globalAlpha = b.fade ? (b.alpha||1) : 1;
    ctx.drawImage(imgs.boss, b.x, b.y, b.w, b.h);
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(b.x, b.y - 10, b.w, 6);
    ctx.fillStyle = 'lime'; ctx.fillRect(b.x, b.y - 10, b.w * (b.hp / 40), 6);
    ctx.restore();
  });

  // player (blink)
  if(player.blinkUntil && player.blinkUntil > now()){
    if(Math.floor(now()/100) % 2 === 0) ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h);
  } else {
    ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h);
  }

  // draw bullets
  bulletsP.forEach(b => ctx.drawImage(imgs.bulletP, b.x, b.y, b.w, b.h));
  bulletsE.forEach(b => {
    const img = (b.color === 'green') ? imgs.bulletP : imgs.bulletE;
    ctx.drawImage(img, b.x, b.y, b.w, b.h);
  });
}

/* ---------- MAIN LOOP ---------- */
function loop(ts){
  if(!running) return;
  update(ts);
  draw();
  updateHUD();
  requestAnimationFrame(loop);
}

/* ---------- INPUT: SWIPE (step) and DRAG in bottom region ---------- */
let touchStartX = null, touchStartTime = 0;
let dragging = false;
let lastTouchX = null;
const DRAG_AREA_HEIGHT_RATIO = 0.25; // bottom 25% is drag area

canvas.addEventListener('touchstart', (e) => {
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartTime = Date.now();
  lastTouchX = t.clientX;
  // decide if touch is in bottom drag area
  const rect = frame.getBoundingClientRect();
  const localY = t.clientY - rect.top;
  dragging = localY > rect.height * (1 - DRAG_AREA_HEIGHT_RATIO);
  ensurePlayBgm();
}, {passive:true});

canvas.addEventListener('touchmove', (e) => {
  if(!dragging) return; // only follow if in drag area
  e.preventDefault();
  const t = e.touches[0];
  const dx = t.clientX - lastTouchX;
  // apply small scale so player moves naturally
  player.x += dx;
  clampPlayer();
  lastTouchX = t.clientX;
}, {passive:false});

canvas.addEventListener('touchend', (e) => {
  // If it was a swipe (quick horizontal delta) and NOT a dragging move, treat as step
  if(!dragging && touchStartX !== null){
    const touch = (e.changedTouches && e.changedTouches[0]) || null;
    if(touch){
      const dx = touch.clientX - touchStartX;
      const dt = Date.now() - touchStartTime;
      if(Math.abs(dx) > SWIPE_THRESHOLD && dt < 700){
        if(dx > 0) player.x += SWIPE_STEP; else player.x -= SWIPE_STEP;
        clampPlayer();
      } else {
        // small tap -> manual extra shot
        playerShoot();
      }
    }
  }
  // reset
  touchStartX = null; touchStartTime = 0; dragging = false; lastTouchX = null;
}, {passive:true});

/* ---------- TIMERS: Auto firing & enemy shots & spawners (using setInterval safe) ---------- */
setInterval(()=>{ if(running) { /* nothing here â€“ player fire controlled by lastPlayerShot timer inside update loop */ } }, 100);

setInterval(()=>{ // enemy automatic fire per enemy (but controlled individually inside update by lastShot)
  // nothing - handled in update by per-enemy lastShot using ENEMY_FIRE_MS
}, 200);

setInterval(()=>{ // guarantee power spawn check (spawnPowerRandom checks only-one rule)
  if(!running) return;
  if(now() - lastPowerSpawn > POWER_SPAWN_MS) { lastPowerSpawn = now(); spawnPowerRandom(); }
}, 500);

/* ---------- POPUP ---------- */
let popupTimer = null;
function showPopup(text){
  popupEl.style.opacity = '1';
  popupEl.style.transform = 'translateX(-50%) translateY(0)';
  popupEl.textContent = text;
  if(popupTimer) clearTimeout(popupTimer);
  popupTimer = setTimeout(()=>{ popupEl.style.opacity = '0'; popupEl.style.transform = 'translateX(-50%) translateY(-10px)'; }, 1400);
}

/* ---------- START / INIT ---------- */
function startGame(){
  loadingEl.style.display = 'none';
  fitCanvas();
  positionPlayer();
  ensurePlayBgm();
  running = true;
  lastPlayerShot = now();
  lastEnemySpawn = now();
  lastPowerSpawn = now();
  // set intervals for enemy spawn and consistent enemy fire control
  setInterval(()=>{ if(running) { spawnEnemy(); } }, ENEMY_SPAWN_MS);
  // auto-run loop
  requestAnimationFrame(loop);
}

/* ---------- WAIT FOR IMAGES ---------- */
(function waitReady(){
  if(Object.keys(imgs).length === Object.keys(PATHS).length) {
    // everything loaded
    // small tweak: if any images are zero-size, still set player default
    positionPlayer();
    startGame();
  } else setTimeout(waitReady, 120);
})();

</script>
</body>
</html>
