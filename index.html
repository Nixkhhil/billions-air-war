<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Aircraft - Mobile (Swipe)</title>
<style>
  :root{--topbar:10vh;--gameh:75vh;--botbar:15vh}
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;touch-action:none;-webkit-user-select:none;user-select:none}
  /* layout: top black, centered gameplay canvas, bottom black */
  .wrap{width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .topbar{height:var(--topbar);width:100%;background:#000;flex:0 0 var(--topbar)} 
  .frame{width:100%;height:var(--gameh);max-width:900px;position:relative;overflow:hidden;background:#000;flex:0 0 var(--gameh)}
  canvas{display:block;width:100%;height:100%}
  .bottombar{height:var(--botbar);width:100%;background:#000;flex:0 0 var(--botbar)}
  /* HUD overlay inside frame */
  .hud{position:absolute;left:8px;top:8px;z-index:50;color:#fff;font-family:Arial,Helvetica,sans-serif}
  .hud .score{font-weight:700}
  .hud .hearts img{width:34px;height:34px;margin-left:6px}
  .power-row{position:absolute;right:8px;top:8px;display:flex;flex-direction:column;gap:8px;z-index:50}
  .power-row img{width:44px;height:44px}
  #loading{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;z-index:60}
  @media(max-width:420px){ .hud .hearts img{width:30px;height:30px} .power-row img{width:38px;height:38px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar"></div>

  <div class="frame" id="frame">
    <canvas id="canvas"></canvas>

    <div class="hud" id="hud">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="hearts" id="hearts">
        <img src="./assets/heart.png" alt="h"><img src="./assets/heart.png" alt="h"><img src="./assets/heart.png" alt="h">
      </div>
    </div>

    <div class="power-row" id="powerRow" style="display:none"></div>
    <div id="loading">Loading assets... 0%</div>
  </div>

  <div class="bottombar"></div>
</div>

<audio id="bgm" src="./sounds/bgm.mpeg" loop></audio>

<script>
/* Final mobile-only game (swipe controls, no buttons) */
/* ---------- CONFIG ---------- */
const ASSET = {
  bg: './assets/background.png',
  player: './assets/player.png',
  enemy: './assets/enemy.png',
  boss: './assets/boss.png',
  bulletP: './assets/bullet_green.png',
  bulletE: './assets/bullet_red.png',
  powerDouble: './assets/power_double_fire.png',
  powerShield: './assets/power_shield.png',
  powerLife: './assets/power_extra_life.png',
  heart: './assets/heart.png'
};
const AUTO_FIRE_MS = 1200;      // ~1.2s between auto shots (you wanted ~1.5s; this is slightly faster)
const ENEMY_SPAWN_MS = 3000;    // spawn enemies every ~3s (balanced)
const ENEMY_SHOT_MIN_MS = 1400; // enemy will shoot not faster than this on average
const POWER_SPAWN_CHANCE = 0.22; // chance to drop power on enemy death

/* ---------- CANVAS & FRAME ---------- */
const frame = document.getElementById('frame');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function fitCanvas(){
  const rect = frame.getBoundingClientRect();
  canvas.width = Math.round(rect.width);
  canvas.height = Math.round(rect.height);
}
fitCanvas();
window.addEventListener('resize', () => { fitCanvas(); positionPlayer(); });

/* ---------- LOAD IMAGES ---------- */
const imgs = {};
let remaining = Object.keys(ASSET).length;
const loadingEl = document.getElementById('loading');
for (const [k,p] of Object.entries(ASSET)){
  const img = new Image();
  img.src = p;
  img.onload = ()=>{ imgs[k]=img; remaining--; loadingEl.textContent = `Loading assets... ${Math.round((Object.keys(ASSET).length-remaining)/Object.keys(ASSET).length*100)}%`; if(remaining===0) init(); };
  img.onerror = ()=>{ loadingEl.textContent = `Asset load failed: ${p}`; console.error('Asset load error',p); };
}

/* ---------- AUDIO ---------- */
const bgm = document.getElementById('bgm'); bgm.volume = 0.36;
function ensurePlayBgm(){ bgm.play().catch(()=>{ document.addEventListener('touchstart', ()=> bgm.play(), {once:true}); }); }

/* ---------- STATE ---------- */
let running = false;
let score = 0;
const scoreEl = document.getElementById('score');
const heartsEl = document.getElementById('hearts');
const powerRow = document.getElementById('powerRow');

const player = { x:0, y:0, w:96, h:96, speed:7, lives:3, blinkUntil:0, shieldUntil:0, fireLevel:0 };
let bgY = 0;

let enemies = [];   // {x,y,w,h,speed,hits,fade,alpha,lastShot}
let bosses = [];    // {x,y,w,h,vx,hp,fade,alpha}
let bulletsP = [];  // {x,y,w,h,spd}
let bulletsE = [];  // {x,y,w,h,spd,color}
let powers = [];    // {x,y,w,h,type,vy}

let lastAutoFire = 0;
let lastSpawn = 0;

/* spawn flags for bosses */
let spawn200=false, spawn600=false, spawn1000=false;

/* ---------- HELPERS ---------- */
function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function now(){ return performance.now(); }
function rectOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

/* ---------- HUD ---------- */
function updateHUD(){
  scoreEl.textContent = score;
  const imgsHTML = [];
  for(let i=0;i<3;i++){
    const display = (i < player.lives) ? 'inline-block' : 'none';
    heartsEl.children[i].style.display = display;
  }
  powerRow.innerHTML = '';
  if(player.fireLevel>0){
    const img = document.createElement('img'); img.src = ASSET.powerDouble; img.title = player.fireLevel===1?'Double Fire':'Triple Fire'; powerRow.appendChild(img);
  }
  if(player.shieldUntil > Date.now()){
    const img = document.createElement('img'); img.src = ASSET.powerShield; img.title = 'Shield'; powerRow.appendChild(img);
  }
  powerRow.style.display = powerRow.children.length ? 'flex' : 'none';
}

/* ---------- SIZING ---------- */
function positionPlayer(){
  // scale player relative to frame
  player.w = Math.round(Math.min(canvas.width * 0.14, imgs.player.width));
  player.h = Math.round(player.w * (imgs.player.height / imgs.player.width));
  player.x = (canvas.width - player.w) / 2;
  player.y = canvas.height - player.h - Math.round(canvas.height * 0.06);
  clampPlayer();
}
function clampPlayer(){ 
  player.x = clamp(player.x, 6, canvas.width - player.w - 6);
  player.y = clamp(player.y, 6, canvas.height - player.h - 6);
}

/* ---------- SPAWN ---------- */
function spawnEnemy(){
  const w = Math.round(Math.min(canvas.width * 0.12, imgs.enemy.width));
  const h = Math.round(w * (imgs.enemy.height / imgs.enemy.width));
  enemies.push({ x: rand(8, canvas.width - w - 8), y: -h - 8, w, h, speed: rand(1.1,1.9), hits:0, fade:false, alpha:1, lastShot: Date.now() + rand(200,1200) });
}
function spawnPower(x,y){
  const types = ['life','double','shield'];
  const type = types[Math.floor(Math.random()*types.length)];
  const w = Math.round(Math.min(canvas.width*0.09, imgs.powerDouble.width));
  const h = Math.round(w * (imgs.powerDouble.height / imgs.powerDouble.width));
  powers.push({ x: x + rand(-10,10), y, w, h, type, vy: 1.2 });
}
function spawnBossCount(n){
  bosses = [];
  const w = Math.round(Math.min(canvas.width*0.28, imgs.boss.width));
  const h = Math.round(w * (imgs.boss.height / imgs.boss.width));
  if(n===1){
    bosses.push({ x:(canvas.width-w)/2, y:40, w, h, vx:1.2, hp:40, fade:false, alpha:1 });
  } else if(n===2){
    bosses.push({ x:60, y:40, w, h, vx:1.2, hp:40, fade:false, alpha:1 });
    bosses.push({ x:canvas.width-60-w, y:40, w, h, vx:-1.2, hp:40, fade:false, alpha:1 });
  } else if(n===3){
    bosses.push({ x:40, y:30, w, h, vx:1.2, hp:40, fade:false, alpha:1 });
    bosses.push({ x:(canvas.width-w)/2, y:20, w, h, vx:0.8, hp:40, fade:false, alpha:1 });
    bosses.push({ x:canvas.width-40-w, y:30, w, h, vx:-1.2, hp:40, fade:false, alpha:1 });
  }
}

/* ---------- FIRE ---------- */
function autoFireTick(){
  const bw = Math.round(player.w*0.14), bh = Math.round(player.h*0.28);
  if(player.fireLevel===0){
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
  } else if(player.fireLevel===1){
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
  } else {
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 6, w: bw, h: bh, spd: 14 });
  }
}

function enemyFire(e){
  const bw = Math.round(e.w*0.12), bh = Math.round(e.h*0.28);
  bulletsE.push({ x: e.x + e.w/2 - bw/2, y: e.y + e.h + 6, w: bw, h: bh, spd: 5, color:'red' });
}

function bossFire(b){
  const bw = Math.round(b.w*0.14), bh = Math.round(b.h*0.28);
  const lanes = [ b.x + 10, b.x + b.w*0.33, b.x + b.w*0.66, b.x + b.w - bw - 10 ];
  for(let i=0;i<4;i++){
    const lx = clamp(lanes[i], 6, canvas.width - bw - 6);
    bulletsE.push({ x: lx, y: b.y + b.h + 6, w: bw, h: bh, spd: 6, color:'green' });
  }
}

/* ---------- COLLISIONS & UPDATES ---------- */
let lastTime = performance.now();

function update(ts){
  const dt = Math.max(1, ts - lastTime);
  lastTime = ts;

  // background scroll
  bgY += 1.6 * (dt/16);
  if(bgY >= canvas.height) bgY = 0;

  // auto-fire
  if(Date.now() - lastAutoFire > AUTO_FIRE_MS){
    lastAutoFire = Date.now();
    autoFireTick();
  }

  // spawn enemies occasionally
  if(Date.now() - lastSpawn > ENEMY_SPAWN_MS){
    lastSpawn = Date.now();
    if(Math.random() < 0.9) spawnEnemy();
    if(Math.random() < 0.08) spawnPower(rand(40, canvas.width-80), -40);
  }

  // update enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.speed * (dt/16);
    // enemy shot timing
    if(Date.now() - e.lastShot > (ENEMY_SHOT_MIN_MS + Math.random()*1200)){
      e.lastShot = Date.now();
      enemyFire(e);
    }
    if(e.y > canvas.height + 60) enemies.splice(i,1);
  }

  // update bosses
  for(let i=bosses.length-1;i>=0;i--){
    const b = bosses[i];
    b.x += b.vx * (dt/16);
    if(b.x < 8 || b.x + b.w > canvas.width - 8) b.vx *= -1;
    if(Math.random() < 0.008) bossFire(b);
  }

  // bullets update
  for(let i=bulletsP.length-1;i>=0;i--){
    bulletsP[i].y -= bulletsP[i].spd * (dt/16);
    if(bulletsP[i].y < -60) bulletsP.splice(i,1);
  }
  for(let i=bulletsE.length-1;i>=0;i--){
    bulletsE[i].y += bulletsE[i].spd * (dt/16);
    if(bulletsE[i].y > canvas.height + 120) bulletsE.splice(i,1);
  }

  // powers update
  for(let i=powers.length-1;i>=0;i--){
    powers[i].y += powers[i].vy * (dt/16);
    if(powers[i].y > canvas.height + 60) powers.splice(i,1);
  }

  // collisions: player bullets -> enemies (3 hits)
  for(let i=bulletsP.length-1;i>=0;i--){
    const pb = bulletsP[i];
    // enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(rectOverlap({x:pb.x,y:pb.y,w:pb.w,h:pb.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
        bulletsP.splice(i,1);
        e.hits++;
        e.alpha = 1;
        if(e.hits >= 3){
          e.fade = true; e.alpha = 1;
          if(Math.random() < POWER_SPAWN_CHANCE) spawnPower(e.x, e.y);
          score += 10; updateHUD();
        }
        break;
      }
    }
    // bosses (each bullet = 1 HP)
    for(let bi=bosses.length-1;bi>=0;bi--){
      const bo = bosses[bi];
      if(rectOverlap({x:pb.x,y:pb.y,w:pb.w,h:pb.h},{x:bo.x,y:bo.y,w:bo.w,h:bo.h})){
        bulletsP.splice(i,1);
        bo.hp -= 1;
        bo.alpha = 1;
        if(bo.hp <= 0){
          bo.fade = true; bo.alpha = 1;
        }
        score += 1; updateHUD();
        break;
      }
    }
  }

  // fade removal for enemies & bosses
  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].fade){
      enemies[i].alpha -= 0.06 * (dt/16);
      if(enemies[i].alpha <= 0) enemies.splice(i,1);
    }
  }
  for(let i=bosses.length-1;i>=0;i--){
    if(bosses[i].fade){
      bosses[i].alpha -= 0.03 * (dt/16);
      if(bosses[i].alpha <= 0){ bosses.splice(i,1); score += 100; updateHUD(); }
    }
  }

  // bulletsE -> player
  for(let i=bulletsE.length-1;i>=0;i--){
    const eb = bulletsE[i];
    if(rectOverlap({x:eb.x,y:eb.y,w:eb.w,h:eb.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      bulletsE.splice(i,1);
      if(player.shieldUntil > Date.now()){ /* protected */ } else {
        player.lives--; player.blinkUntil = Date.now() + 1000; updateHUD();
        if(player.lives <= 0){ running = false; setTimeout(()=>{ alert('Game Over! Score: '+score); location.reload(); }, 80); return; }
      }
    }
  }

  // player picks powerups
  for(let i=powers.length-1;i>=0;i--){
    const p = powers[i];
    if(rectOverlap({x:p.x,y:p.y,w:p.w,h:p.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      if(p.type === 'life'){ if(player.lives < 3){ player.lives++; updateHUD(); } }
      else if(p.type === 'double'){ if(player.fireLevel < 2) player.fireLevel++; }
      else if(p.type === 'shield'){ player.shieldUntil = Date.now() + 5000; updateHUD(); }
      powers.splice(i,1);
    }
  }

  // boss spawn thresholds
  if(score >= 200 && !spawn200){ spawnBossCount(1); spawn200=true; }
  if(score >= 600 && !spawn600){ spawnBossCount(2); spawn600=true; }
  if(score >= 1000 && !spawn1000){ spawnBossCount(3); spawn1000=true; }

  // victory condition
  if(score >= 1000 && bosses.length===0 && enemies.length===0){ running=false; setTimeout(()=>{ alert('You Win! Score: '+score); location.reload(); },120); return; }
}

/* ---------- DRAW ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background
  if(imgs.bg){
    const h = canvas.height;
    const y = (bgY % h);
    ctx.drawImage(imgs.bg, 0, y - h, canvas.width, h);
    ctx.drawImage(imgs.bg, 0, y, canvas.width, h);
  } else { ctx.fillStyle='#071022'; ctx.fillRect(0,0,canvas.width,canvas.height); }

  // powers
  powers.forEach(p => {
    if(p.type==='life') ctx.drawImage(imgs.powerLife, p.x, p.y, p.w, p.h);
    else if(p.type==='double') ctx.drawImage(imgs.powerDouble, p.x, p.y, p.w, p.h);
    else if(p.type==='shield') ctx.drawImage(imgs.powerShield, p.x, p.y, p.w, p.h);
  });

  // enemies
  enemies.forEach(e => { ctx.save(); ctx.globalAlpha = e.fade ? (e.alpha||1) : 1; ctx.drawImage(imgs.enemy, e.x, e.y, e.w, e.h); ctx.restore(); });

  // bosses
  bosses.forEach(b => {
    ctx.save(); ctx.globalAlpha = b.fade ? (b.alpha||1) : 1; ctx.drawImage(imgs.boss, b.x, b.y, b.w, b.h);
    // hp bar (out of 40)
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(b.x, b.y-10, b.w, 6);
    ctx.fillStyle='lime'; ctx.fillRect(b.x, b.y-10, b.w * (b.hp / 40), 6);
    ctx.restore();
  });

  // player blink
  if(player.blinkUntil > Date.now()){ if(Math.floor(Date.now()/100)%2===0) ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h); } 
  else ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h);

  // bullets
  bulletsP.forEach(b => ctx.drawImage(imgs.bulletP, b.x, b.y, b.w, b.h));
  bulletsE.forEach(b => { if(b.color==='green') ctx.drawImage(imgs.bulletP, b.x, b.y, b.w, b.h); else ctx.drawImage(imgs.bulletE, b.x, b.y, b.w, b.h); });
}

/* ---------- MAIN LOOP ---------- */
let lastRender = performance.now();
function loop(t){
  if(!running) return;
  update(t);
  draw();
  updateHUD();
  requestAnimationFrame(loop);
}

/* ---------- INPUT: SWIPE/DRAG for mobile ---------- */
let dragging=false, lastTouchX=null;
canvas.addEventListener('touchstart', e=>{ dragging=true; lastTouchX = e.touches[0].clientX; ensurePlayBgm(); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); if(dragging){ const tx = e.touches[0].clientX; const rect = canvas.getBoundingClientRect(); const dx = tx - lastTouchX; player.x += dx * (canvas.width / rect.width); lastTouchX = tx; clampPlayer(); } }, {passive:false});
canvas.addEventListener('touchend', e=>{ dragging=false; lastTouchX=null; }, {passive:false});

// also allow simple tap to manualFire (extra volley)
canvas.addEventListener('click', ()=>{ autoFireTick(); });

/* ---------- INIT ---------- */
function init(){
  loadingEl.style.display = 'none';
  fitCanvas();
  positionPlayer();
  ensurePlayBgm();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
  // small periodic power spawn to avoid clustering
  setInterval(()=>{ if(Math.random() < 0.22) spawnPower(rand(40, canvas.width-80), -40); }, 9000);
}

/* ---------- Wait for assets (in case already loaded) ---------- */
(function waitReady(){ if(Object.keys(imgs).length === Object.keys(ASSET).length) init(); else setTimeout(waitReady,120); })();

</script>
</body>
</html>
