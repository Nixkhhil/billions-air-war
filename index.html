<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Aircraft Battle — Mobile</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;overflow:hidden;-webkit-user-select:none;user-select:none}
  canvas{display:block; width:100vw; height:100vh}
  #hud{position:fixed;left:10px;top:10px;color:#fff;font-family:Arial,Helvetica,sans-serif;z-index:60}
  #hud .score{font-weight:700;font-size:18px;margin-bottom:6px}
  #hud .hearts img{width:36px;height:36px;margin-right:6px;vertical-align:middle}
  .power-row{position:fixed;right:12px;top:12px;display:flex;flex-direction:column;gap:8px;z-index:65}
  .power-row img{width:48px;height:48px}
  #loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-family:Arial;z-index:80}
  .controls{position:fixed;left:8px;right:8px;bottom:12px;display:flex;justify-content:space-between;z-index:70;pointer-events:none}
  .group{display:flex;gap:8px;pointer-events:auto}
  .btn{width:60px;height:60px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;touch-action:none}
  @media(max-width:420px){ .btn{width:48px;height:48px} .hud .hearts img{width:30px;height:30px} .power-row img{width:42px;height:42px} }
</style>
</head>
<body>

<div id="hud">
  <div class="score">Score: <span id="score">0</span></div>
  <div class="hearts" id="hearts">
    <img src="./assets/heart.png" id="h1"><img src="./assets/heart.png" id="h2"><img src="./assets/heart.png" id="h3">
  </div>
</div>

<div class="power-row" id="powerRow" style="display:none"></div>

<canvas id="gameCanvas"></canvas>
<div id="loading">Loading assets... 0%</div>

<div class="controls">
  <div class="group">
    <div class="btn" id="leftBtn">◀</div>
    <div class="btn" id="rightBtn">▶</div>
  </div>
  <div class="group">
    <div class="btn" id="pauseBtn">PAUSE</div>
  </div>
</div>

<audio id="bgm" src="./sounds/bgm.mpeg" loop></audio>

<script>
/* ---------------- CONFIG ---------------- */
const ASSET_PATHS = {
  bg: './assets/background.png',
  player: './assets/player.png',
  enemy: './assets/enemy.png',
  boss: './assets/boss.png',
  bulletP: './assets/bullet_green.png',
  bulletE: './assets/bullet_red.png',
  powerDouble: './assets/power_double_fire.png',
  powerShield: './assets/power_shield.png',
  powerLife: './assets/power_extra_life.png',
  heart: './assets/heart.png'
};
const BGM_PATH = './sounds/bgm.mpeg';

/* ------------- CANVAS -------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function fit(){ canvas.width = innerWidth; canvas.height = innerHeight; }
fit(); window.addEventListener('resize', fit);

/* ---------- LOAD IMAGES ---------- */
const imgs = {};
let assetsLoaded = 0;
const assetKeys = Object.keys(ASSET_PATHS);
const loadingEl = document.getElementById('loading');

assetKeys.forEach(k=>{
  const img = new Image();
  img.src = ASSET_PATHS[k];
  img.onload = ()=>{ imgs[k] = img; assetsLoaded++; loadingEl.textContent = `Loading assets... ${Math.round((assetsLoaded/assetKeys.length)*100)}%`; if(assetsLoaded===assetKeys.length) onAssetsReady(); }
  img.onerror = ()=>{ console.error('Failed to load', ASSET_PATHS[k]); loadingEl.textContent = 'Asset load error — check files'; }
});

/* ---------- AUDIO (BGM) ---------- */
const bgm = document.getElementById('bgm');
bgm.volume = 0.45;
function ensurePlayBgm(){ bgm.play().catch(()=>document.addEventListener('touchstart', ()=> bgm.play(), {once:true})); }

/* ------------ STATE -------------- */
let running = false;
let score = 0;
const scoreEl = document.getElementById('score');
const heartEls = [document.getElementById('h1'), document.getElementById('h2'), document.getElementById('h3')];
const powerRow = document.getElementById('powerRow');

const player = { w:96, h:96, x:100, y:100, speed:6, lives:3, blinkUntil:0, shieldUntil:0, fireLevel:0 }; // fireLevel: 0 single,1 double,2 triple
let bgY = 0, bgSpeed = 1.8;

let enemies = [];    // {x,y,w,h,speed,hits,fade,alpha}
let bosses = [];     // {x,y,w,h,vx,hp,fade,alpha}
let bulletsP = [];   // {x,y,w,h,spd}
let bulletsE = [];   // {x,y,w,h,spd,color}
let powers = [];     // {x,y,w,h,type,vy}

let lastSpawn = 0;
let lastAutoFire = 0;

/* boss spawn flags */
let bossSpawnedAt200=false, bossSpawnedAt600=false, bossSpawnedAt1000=false;

/* ---------- INPUT HANDLING ---------- */
const keyState = {};
window.addEventListener('keydown', e=>{ keyState[e.key]=true; });
window.addEventListener('keyup', e=>{ keyState[e.key]=false; });

let touchLeft=false, touchRight=false, dragging=false, lastTouchX=null;
document.getElementById('leftBtn').addEventListener('touchstart', e=>{ e.preventDefault(); touchLeft=true; }, {passive:false});
document.getElementById('leftBtn').addEventListener('touchend', e=>{ e.preventDefault(); touchLeft=false; }, {passive:false});
document.getElementById('rightBtn').addEventListener('touchstart', e=>{ e.preventDefault(); touchRight=true; }, {passive:false});
document.getElementById('rightBtn').addEventListener('touchend', e=>{ e.preventDefault(); touchRight=false; }, {passive:false});
document.getElementById('pauseBtn').addEventListener('click', ()=>{ running = !running; if(running) requestAnimationFrame(loop); });

canvas.addEventListener('touchstart', e=>{ dragging=true; lastTouchX = e.touches[0].clientX; ensurePlayBgm(); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); if(dragging){ const tx = e.touches[0].clientX; const dx = tx - lastTouchX; player.x += dx; lastTouchX = tx; } }, {passive:false});
canvas.addEventListener('touchend', e=>{ dragging=false; lastTouchX=null; }, {passive:false});
canvas.addEventListener('mousedown', e=>{ dragging=true; lastTouchX = e.clientX; ensurePlayBgm(); });
canvas.addEventListener('mousemove', e=>{ if(dragging){ const dx = e.clientX - lastTouchX; player.x += dx; lastTouchX = e.clientX; }});
canvas.addEventListener('mouseup', e=>{ dragging=false; lastTouchX=null; });

/* ---------- HELPERS ---------- */
function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function now(){ return performance.now(); }
function rectOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

/* ---------- HUD ---------- */
function updateHUD(){
  scoreEl.textContent = score;
  for(let i=0;i<3;i++) heartEls[i].style.display = (i < player.lives) ? 'inline-block' : 'none';
  // power icons
  powerRow.innerHTML = '';
  if(player.fireLevel>0){
    const img = document.createElement('img'); img.src = ASSET_PATHS.powerDouble; img.title = (player.fireLevel===1?'Double Fire':'Triple Fire'); powerRow.appendChild(img);
  }
  if(player.shieldUntil > now()){
    const img = document.createElement('img'); img.src = ASSET_PATHS.powerShield; img.title = 'Shield'; powerRow.appendChild(img);
  }
  powerRow.style.display = powerRow.children.length ? 'flex' : 'none';
}

/* ---------- SPAWNING ---------- */
function spawnEnemy(){
  const w = Math.round(Math.min(canvas.width*0.12, imgs.enemy.width));
  const h = Math.round(w * (imgs.enemy.height / imgs.enemy.width));
  enemies.push({ x: rand(8, canvas.width - w - 8), y: -h - 8, w, h, speed: rand(1.2,2.4), hits:0, fade:false, alpha:1 });
}
function spawnPower(x,y){
  const types = ['life','double','shield'];
  const t = types[Math.floor(Math.random()*types.length)];
  const w = Math.round(Math.min(canvas.width*0.09, imgs.powerDouble.width));
  const h = Math.round(w * (imgs.powerDouble.height / imgs.powerDouble.width));
  powers.push({ x, y, w, h, type: t, vy: 1.3 });
}
function spawnBossCount(n){
  bosses = [];
  const w = Math.round(Math.min(canvas.width*0.28, imgs.boss.width));
  const h = Math.round(w * (imgs.boss.height / imgs.boss.width));
  if(n===1){
    bosses.push({ x:(canvas.width-w)/2, y:40, w, h, vx:1.4, hp:40, fade:false, alpha:1 });
  } else if(n===2){
    bosses.push({ x:60, y:40, w, h, vx:1.4, hp:40, fade:false, alpha:1 });
    bosses.push({ x:canvas.width-60-w, y:40, w, h, vx:-1.4, hp:40, fade:false, alpha:1 });
  } else if(n===3){
    bosses.push({ x:40, y:30, w, h, vx:1.4, hp:40, fade:false, alpha:1 });
    bosses.push({ x:(canvas.width-w)/2, y:20, w, h, vx:0.9, hp:40, fade:false, alpha:1 });
    bosses.push({ x:canvas.width-40-w, y:30, w, h, vx:-1.4, hp:40, fade:false, alpha:1 });
  } else if(n===4){
    // not used but kept
  }
}

/* ---------- SHOOT ---------- */
function autoFireTick(){
  const bw = Math.round(player.w*0.14), bh = Math.round(player.h*0.28);
  if(player.fireLevel===0){
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
  } else if(player.fireLevel===1){
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
  } else {
    bulletsP.push({ x: player.x + player.w/2 - bw/2, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + 6, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
    bulletsP.push({ x: player.x + player.w - 6 - bw, y: player.y - bh - 4, w: bw, h: bh, spd: 14 });
  }
}

/* enemy fires red bullet */
function enemyFire(e){
  const bw = Math.round(e.w*0.12), bh = Math.round(e.h*0.28);
  bulletsE.push({ x: e.x + e.w/2 - bw/2, y: e.y + e.h + 4, w: bw, h: bh, spd: 5, color:'red' });
}

/* boss fires 4-lane bullets similar to player (green style) */
function bossFire(b){
  const bw = Math.round(b.w*0.14), bh = Math.round(b.h*0.28);
  const lanes = [
    b.x + bw, b.x + b.w/2 - bw/2, b.x + b.w - bw - 4, b.x + b.w/2 - bw/2 - 40
  ];
  for(let i=0;i<4;i++){
    const lx = clamp(lanes[i], 6, canvas.width - bw - 6);
    bulletsE.push({ x: lx, y: b.y + b.h + 6, w: bw, h: bh, spd: 6, color:'green' });
  }
}

/* ---------- COLLISIONS & UPDATES ---------- */
let lastTime = performance.now();
let lastSpawnTime = 0;
let lastAutoFireTime = 0;

function update(ts){
  const dt = Math.max(1, ts - lastTime);
  lastTime = ts;

  // background scroll
  bgY += bgSpeed * (dt/16);
  if(bgY >= canvas.height) bgY = 0;

  // movement (keyboard or touch buttons)
  if(keyState.ArrowLeft || touchLeft) player.x -= player.speed * (dt/16);
  if(keyState.ArrowRight || touchRight) player.x += player.speed * (dt/16);
  player.x = clamp(player.x, 6, canvas.width - player.w - 6);

  // spawn enemies
  if(Date.now() - lastSpawn > 650){
    lastSpawn = Date.now();
    if(Math.random() < 0.9) spawnEnemy();
    if(Math.random() < 0.08) spawnPower(rand(40, canvas.width-80), -40);
  }

  // auto fire
  if(Date.now() - lastAutoFire > 220){
    lastAutoFire = Date.now();
    autoFireTick();
  }

  // update enemies positions
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.speed * (dt/16);
    // slight chance to shoot
    if(Math.random() < 0.005) enemyFire(e);
    if(e.y > canvas.height + 60) enemies.splice(i,1);
  }

  // update bosses movement & fire occasionally
  for(let i=bosses.length-1;i>=0;i--){
    const b = bosses[i];
    b.x += b.vx * (dt/16);
    if(b.x < 8 || b.x + b.w > canvas.width - 8) b.vx *= -1;
    if(Math.random() < 0.015) bossFire(b);
  }

  // update bullets
  for(let i=bulletsP.length-1;i>=0;i--){
    bulletsP[i].y -= bulletsP[i].spd * (dt/16);
    if(bulletsP[i].y < -60) bulletsP.splice(i,1);
  }
  for(let i=bulletsE.length-1;i>=0;i--){
    bulletsE[i].y += bulletsE[i].spd * (dt/16);
    if(bulletsE[i].y > canvas.height + 80) bulletsE.splice(i,1);
  }

  // update powers
  for(let i=powers.length-1;i>=0;i--){
    powers[i].y += powers[i].vy * (dt/16);
    if(powers[i].y > canvas.height + 60) powers.splice(i,1);
  }

  // player bullets -> enemies (needs 3 hits)
  for(let i=bulletsP.length-1;i>=0;i--){
    const bp = bulletsP[i];
    // enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(rectOverlap({x:bp.x,y:bp.y,w:bp.w,h:bp.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
        bulletsP.splice(i,1);
        e.hits++;
        // small flash (set alpha temporarily)
        e.alpha = 1;
        if(e.hits >= 3){
          e.fade = true; e.alpha = 1;
          if(Math.random() < 0.28) spawnPower(e.x, e.y);
          score += 10;
          updateHUD();
        }
        break;
      }
    }
    // bosses
    for(let bindex=bosses.length-1;bindex>=0;bindex--){
      const bo = bosses[bindex];
      if(rectOverlap({x:bp.x,y:bp.y,w:bp.w,h:bp.h},{x:bo.x,y:bo.y,w:bo.w,h:bo.h})){
        bulletsP.splice(i,1);
        bo.hp -= 1; // each bullet counts 1 toward 40
        bo.alpha = 1;
        if(bo.hp <= 0){
          bo.fade = true; bo.alpha = 1;
        }
        score += 1;
        updateHUD();
        break;
      }
    }
  }

  // fade & remove enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.fade){
      e.alpha -= 0.06 * (dt/16);
      if(e.alpha <= 0) enemies.splice(i,1);
    }
  }
  // fade & remove bosses, give big score on death
  for(let i=bosses.length-1;i>=0;i--){
    const b = bosses[i];
    if(b.fade){
      b.alpha -= 0.03 * (dt/16);
      if(b.alpha <= 0){
        bosses.splice(i,1);
        score += 100;
        updateHUD();
      }
    }
  }

  // enemy bullets -> player
  for(let i=bulletsE.length-1;i>=0;i--){
    const eb = bulletsE[i];
    if(rectOverlap({x:eb.x,y:eb.y,w:eb.w,h:eb.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      bulletsE.splice(i,1);
      if(player.shieldUntil > Date.now()){
        // shield active, no life lost
      } else {
        player.lives--; player.blinkUntil = Date.now() + 1000; updateHUD();
        if(player.lives <= 0){
          running = false;
          setTimeout(()=>{ alert('Game Over! Final Score: '+score); location.reload(); }, 100);
          return;
        }
      }
    }
  }

  // player picks up powers
  for(let i=powers.length-1;i>=0;i--){
    const p = powers[i];
    if(rectOverlap({x:p.x,y:p.y,w:p.w,h:p.h},{x:player.x,y:player.y,w:player.w,h:player.h})){
      if(p.type === 'life'){
        if(player.lives < 3){ player.lives++; updateHUD(); }
      } else if(p.type === 'double'){
        if(player.fireLevel < 2) player.fireLevel++;
      } else if(p.type === 'shield'){
        player.shieldUntil = Date.now() + 5000; updateHUD();
      }
      powers.splice(i,1);
    }
  }

  // boss spawn thresholds: 200, 600, 1000
  if(score >= 200 && !bossSpawnedAt200){ spawnBossCount(1); bossSpawnedAt200 = true; }
  if(score >= 600 && !bossSpawnedAt600){ spawnBossCount(2); bossSpawnedAt600 = true; }
  if(score >= 1000 && !bossSpawnedAt1000){ spawnBossCount(3); bossSpawnedAt1000 = true; }

  // win condition: after final bosses dead (post-1000)
  if(score >= 1000 && bosses.length === 0 && enemies.length === 0){
    running = false;
    setTimeout(()=>{ alert('You defeated final wave! Score: '+score); location.reload(); }, 120);
  }
}

/* ---------- DRAW ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw background twice for vertical scroll
  if(imgs.bg){
    const h = canvas.height;
    const y = (bgY % h);
    ctx.drawImage(imgs.bg, 0, y - h, canvas.width, h);
    ctx.drawImage(imgs.bg, 0, y, canvas.width, h);
  } else {
    ctx.fillStyle = '#071022'; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // draw powers
  powers.forEach(p => {
    if(p.type === 'life') ctx.drawImage(imgs.powerLife, p.x, p.y, p.w, p.h);
    else if(p.type === 'double') ctx.drawImage(imgs.powerDouble, p.x, p.y, p.w, p.h);
    else if(p.type === 'shield') ctx.drawImage(imgs.powerShield, p.x, p.y, p.w, p.h);
  });

  // enemies
  enemies.forEach(e => {
    ctx.save(); ctx.globalAlpha = e.fade ? (e.alpha||1) : 1;
    ctx.drawImage(imgs.enemy, e.x, e.y, e.w, e.h);
    // small hp dots to show hits (optional)
    ctx.restore();
  });

  // bosses
  bosses.forEach(b => {
    ctx.save(); ctx.globalAlpha = b.fade ? (b.alpha||1) : 1;
    ctx.drawImage(imgs.boss, b.x, b.y, b.w, b.h);
    // hp bar
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(b.x, b.y-10, b.w, 6);
    ctx.fillStyle = 'lime'; ctx.fillRect(b.x, b.y-10, b.w * (b.hp / 40), 6);
    ctx.restore();
  });

  // player (blink)
  if(player.blinkUntil > Date.now()){
    // blink on/off
    if(Math.floor(Date.now()/100) % 2 === 0) ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h);
  } else {
    ctx.drawImage(imgs.player, player.x, player.y, player.w, player.h);
  }

  // bullets
  bulletsP.forEach(b => ctx.drawImage(imgs.bulletP, b.x, b.y, b.w, b.h));
  bulletsE.forEach(b => {
    if(b.color === 'green') ctx.drawImage(imgs.bulletP, b.x, b.y, b.w, b.h);
    else ctx.drawImage(imgs.bulletE, b.x, b.y, b.w, b.h);
  });

  // HUD text (score done in DOM)
}

/* ---------- MAIN LOOP ---------- */
let frameTime = performance.now();
function loop(ts){
  if(!running) return;
  update(ts);
  draw();
  updateHUD();
  requestAnimationFrame(loop);
}

/* ---------- ON ASSETS READY ---------- */
function onAssetsReady(){
  loadingEl.style.display = 'none';
  // scale player & other sizes
  player.w = Math.round(Math.min(canvas.width * 0.14, imgs.player.width));
  player.h = Math.round(player.w * (imgs.player.height / imgs.player.width));
  player.x = (canvas.width - player.w) / 2;
  player.y = canvas.height - player.h - 20;
  ensurePlayBgm();
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

/* ---------- start periodic tasks ---------- */
setInterval(()=>{ if(running){ /* spawn handled in update */ } }, 1000);

/* ---------- small safety: ensure imgs map filled from earlier loader ---------- */
(function waitForReady(){
  if(Object.keys(imgs).length === assetKeys.length){
    onAssetsReady();
  } else {
    setTimeout(waitForReady, 150);
  }
})();

/* ---------- small debug hookup: update HUD initially ---------- */
updateHUD();

</script>
</body>
</html>